{
  "version": 3,
  "sources": ["../src/channel/protocol.ts", "../src/channel/index.ts", "../src/utils/basics.ts", "../src/utils/transform.ts", "../src/video/clipMaskRenderer.ts", "../src/display/renderer.ts", "../src/display/index.ts"],
  "sourcesContent": ["import { ChannelMessageType, ChannelMessage } from \"../types\";\r\n\r\nexport const CHANNEL_NAME = \"mlmap-sync\";\r\nexport const HEARTBEAT_INTERVAL = 2000;\r\nexport const SYNC_INTERVAL = 500;\r\nexport const HEARTBEAT_TIMEOUT = 6000;\r\n\r\nexport function createMessage(type: ChannelMessageType, payload?: any): ChannelMessage {\r\n    return { type, payload, timestamp: Date.now() };\r\n}\r\n", "import { ChannelMessage, ChannelMessageType } from \"../types\";\r\nimport { CHANNEL_NAME, HEARTBEAT_INTERVAL, HEARTBEAT_TIMEOUT, createMessage } from \"./protocol\";\r\n\r\nexport type ChannelRole = \"control\" | \"display\";\r\n\r\nexport class ChannelBridge {\r\n    private channel: BroadcastChannel;\r\n    private role: ChannelRole;\r\n    private listeners: Map<ChannelMessageType, ((payload: any) => void)[]> = new Map();\r\n    private heartbeatTimer: number | null = null;\r\n    private lastPong: number = 0;\r\n    private _connected: boolean = false;\r\n    private onConnectionChange: ((connected: boolean) => void) | null = null;\r\n\r\n    constructor(role: ChannelRole) {\r\n        this.role = role;\r\n        this.channel = new BroadcastChannel(CHANNEL_NAME);\r\n        this.channel.onmessage = (e: MessageEvent<ChannelMessage>) => this.handleMessage(e.data);\r\n\r\n        if (role === \"control\") {\r\n            this.startHeartbeat();\r\n        }\r\n        if (role === \"display\") {\r\n            this.on(\"PING\", () => this.send(\"PONG\"));\r\n            // Small delay to ensure control's listener is ready\r\n            setTimeout(() => this.send(\"DISPLAY_READY\"), 100);\r\n        }\r\n    }\r\n\r\n    get connected(): boolean { return this._connected; }\r\n\r\n    set onConnectionChanged(cb: ((connected: boolean) => void) | null) {\r\n        this.onConnectionChange = cb;\r\n    }\r\n\r\n    send(type: ChannelMessageType, payload?: any): void {\r\n        try {\r\n            this.channel.postMessage(createMessage(type, payload));\r\n        } catch (e) {\r\n            console.warn(\"ChannelBridge: Failed to send message\", type, e);\r\n        }\r\n    }\r\n\r\n    on(type: ChannelMessageType, callback: (payload: any) => void): void {\r\n        if (!this.listeners.has(type)) this.listeners.set(type, []);\r\n        this.listeners.get(type)!.push(callback);\r\n    }\r\n\r\n    off(type: ChannelMessageType, callback: (payload: any) => void): void {\r\n        const cbs = this.listeners.get(type);\r\n        if (cbs) {\r\n            const idx = cbs.indexOf(callback);\r\n            if (idx >= 0) cbs.splice(idx, 1);\r\n        }\r\n    }\r\n\r\n    destroy(): void {\r\n        if (this.heartbeatTimer) clearInterval(this.heartbeatTimer);\r\n        this.channel.close();\r\n        this.listeners.clear();\r\n    }\r\n\r\n    private handleMessage(msg: ChannelMessage): void {\r\n        if (msg.type === \"PONG\" || msg.type === \"DISPLAY_READY\") {\r\n            this.lastPong = Date.now();\r\n            this.setConnected(true);\r\n        }\r\n        const cbs = this.listeners.get(msg.type);\r\n        if (cbs) cbs.forEach(cb => cb(msg.payload));\r\n    }\r\n\r\n    private startHeartbeat(): void {\r\n        this.heartbeatTimer = window.setInterval(() => {\r\n            this.send(\"PING\");\r\n            if (this._connected && Date.now() - this.lastPong > HEARTBEAT_TIMEOUT) {\r\n                this.setConnected(false);\r\n            }\r\n        }, HEARTBEAT_INTERVAL);\r\n    }\r\n\r\n    private setConnected(val: boolean): void {\r\n        if (this._connected !== val) {\r\n            this._connected = val;\r\n            if (this.onConnectionChange) this.onConnectionChange(val);\r\n        }\r\n    }\r\n}\r\n", "import { Layer, Point } from \"../types\";\r\n\r\nexport function getFreePosition(width: number, height: number, layers: Layer[] = []): [number, number] {\r\n    let x = 0, y = 0, tries = 0, maxTries = 100;\r\n    let overlap: boolean;\r\n\r\n    do {\r\n        overlap = false;\r\n        x = Math.random() * (window.innerWidth - width);\r\n        y = Math.random() * (window.innerHeight - height);\r\n\r\n        for (let l of layers) {\r\n            const rect = [\r\n                Math.min(...l.targetPoints.map(p => p[0])),\r\n                Math.min(...l.targetPoints.map(p => p[1])),\r\n                Math.max(...l.targetPoints.map(p => p[0])),\r\n                Math.max(...l.targetPoints.map(p => p[1]))\r\n            ];\r\n            if (!(x + width < rect[0] || x > rect[2] || y + height < rect[1] || y > rect[3])) {\r\n                overlap = true;\r\n                break;\r\n            }\r\n        }\r\n        tries++;\r\n    } while (overlap && tries < maxTries);\r\n\r\n    return [x, y];\r\n};\r\n\r\nexport function clonePoints(points: number[][]): Point[] {\r\n    return points.map(p => p.slice(0, 2) as Point);\r\n};\r\n\r\nexport function distanceTo(x1: number, y1: number, x2: number, y2: number): number {\r\n    return Math.hypot(x2 - x1, y2 - y1);\r\n};\r\n\r\nexport const solve = (() => {\r\n    function r(t: any, nArr: any, o: number, eFunc: any) {\r\n        if (o === nArr.length - 1) return eFunc(t);\r\n        let f: any;\r\n        const u = nArr[o];\r\n        const cArr = Array(u);\r\n        for (f = u - 1; f >= 0; --f) cArr[f] = r(t[f], nArr, o + 1, eFunc);\r\n        return cArr;\r\n    };\r\n    function tfn(rObj: any) {\r\n        const res: number[] = [];\r\n        while (typeof rObj === \"object\") {\r\n            res.push(rObj.length);\r\n            rObj = rObj[0];\r\n        }\r\n        return res;\r\n    };\r\n    function nfn(rObj: any) {\r\n        let n: any, o: any;\r\n        if (typeof rObj === \"object\") {\r\n            n = rObj[0];\r\n            if (typeof n === \"object\") {\r\n                o = n[0];\r\n                return (typeof o === \"object\") ? tfn(rObj) : [rObj.length, n.length];\r\n            }\r\n            return [rObj.length];\r\n        }\r\n        return [];\r\n    };\r\n    function ofn(rArr: any[]) {\r\n        let i: number;\r\n        const n = rArr.length;\r\n        const out = Array(n);\r\n        for (i = n - 1; i >= 0; --i) out[i] = rArr[i];\r\n        return out;\r\n    };\r\n    function efn(tVal: any) {\r\n        return typeof tVal !== \"object\" ? tVal : r(tVal, nfn(tVal), 0, ofn);\r\n    };\r\n    function ffn(rArr: any, tFlag?: boolean) {\r\n        tFlag = tFlag || false;\r\n        let n: any, o: any, fVar: any, uVar: any, a: any, h: any, i: any, l: any, g: any;\r\n        let v = rArr.length;\r\n        const y = v - 1;\r\n        const b = new Array(v);\r\n        if (!tFlag) rArr = efn(rArr);\r\n        for (fVar = 0; fVar < v; ++fVar) {\r\n            i = fVar;\r\n            h = rArr[fVar];\r\n            g = c(h[fVar]);\r\n            for (o = fVar + 1; o < v; ++o) {\r\n                uVar = c(rArr[o][fVar]);\r\n                if (uVar > g) { g = uVar; i = o; }\r\n            }\r\n            b[fVar] = i;\r\n            if (i != fVar) { rArr[fVar] = rArr[i]; rArr[i] = h; h = rArr[fVar]; }\r\n            a = h[fVar];\r\n            for (n = fVar + 1; n < v; ++n) rArr[n][fVar] /= a;\r\n            for (n = fVar + 1; n < v; ++n) {\r\n                l = rArr[n];\r\n                for (o = fVar + 1; o < y; ++o) { l[o] -= l[fVar] * h[o]; ++o; l[o] -= l[fVar] * h[o]; }\r\n                if (o === y) l[o] -= l[fVar] * h[o];\r\n            }\r\n        }\r\n        return { LU: rArr, P: b };\r\n    };\r\n    function ufn(rObj: any, tArr: any) {\r\n        let n: any, o: any, fVar: any, uVar: any, cVar: any;\r\n        const a = rObj.LU;\r\n        const h = a.length;\r\n        const iArr = efn(tArr);\r\n        const lArr = rObj.P;\r\n        for (n = h - 1; n >= 0; --n) iArr[n] = tArr[n];\r\n        for (n = 0; n < h; ++n) {\r\n            fVar = lArr[n];\r\n            if (lArr[n] !== n) { cVar = iArr[n]; iArr[n] = iArr[fVar]; iArr[fVar] = cVar; }\r\n            uVar = a[n];\r\n            for (o = 0; o < n; ++o) iArr[n] -= iArr[o] * uVar[o];\r\n        }\r\n        for (n = h - 1; n >= 0; --n) {\r\n            uVar = a[n];\r\n            for (o = n + 1; o < h; ++o) iArr[n] -= iArr[o] * uVar[o];\r\n            iArr[n] /= uVar[n];\r\n        }\r\n        return iArr;\r\n    };\r\n    const c = Math.abs;\r\n    return function (rMat: any, bVec: any, nOpt?: any) {\r\n        return ufn(ffn(rMat, nOpt), bVec);\r\n    };\r\n})();", "import { solve } from \"./basics\";\r\n\r\nexport function computeTransformMatrix(sourcePoints: number[][], targetPoints: number[][]): string {\r\n    const a: number[][] = [];\r\n    const b: number[] = [];\r\n    for (let i = 0; i < sourcePoints.length; i++) {\r\n        const s = sourcePoints[i];\r\n        const t = targetPoints[i];\r\n        a.push([s[0], s[1], 1, 0, 0, 0, -s[0] * t[0], -s[1] * t[0]]);\r\n        b.push(t[0]);\r\n        a.push([0, 0, 0, s[0], s[1], 1, -s[0] * t[1], -s[1] * t[1]]);\r\n        b.push(t[1]);\r\n    }\r\n    const X = solve(a, b, true);\r\n    return `matrix3d(${X[0]},${X[3]},0,${X[6]},${X[1]},${X[4]},0,${X[7]},0,0,1,0,${X[2]},${X[5]},0,1)`;\r\n}\r\n\r\nexport function applyTransform(element: HTMLElement, sourcePoints: number[][], targetPoints: number[][]): void {\r\n    element.style.transform = computeTransformMatrix(sourcePoints, targetPoints);\r\n    element.style.transformOrigin = \"0px 0px 0px\";\r\n}\r\n", "export interface ClipGroup {\r\n    video: HTMLVideoElement;\r\n    baseTargetPoints: number[][];\r\n    masks: Array<{ targetPoints: number[][] }>;\r\n}\r\n\r\nexport class ClipMaskRenderer {\r\n    private canvas: HTMLCanvasElement;\r\n    private ctx: CanvasRenderingContext2D;\r\n    private running = false;\r\n    private rafId = 0;\r\n    private getClipGroups: () => ClipGroup[];\r\n    public zoom = 1;\r\n\r\n    constructor(getClipGroups: () => ClipGroup[]) {\r\n        this.getClipGroups = getClipGroups;\r\n\r\n        this.canvas = document.createElement(\"canvas\");\r\n        this.canvas.style.position = \"fixed\";\r\n        this.canvas.style.top = \"0\";\r\n        this.canvas.style.left = \"0\";\r\n        this.canvas.style.zIndex = \"999999\";\r\n        this.canvas.style.pointerEvents = \"none\";\r\n\r\n        this.ctx = this.canvas.getContext(\"2d\")!;\r\n\r\n        window.addEventListener(\"resize\", () => this.resize());\r\n        this.resize();\r\n    }\r\n\r\n    get canvasElement(): HTMLCanvasElement { return this.canvas; }\r\n\r\n    resize(): void {\r\n        this.canvas.width = window.innerWidth;\r\n        this.canvas.height = window.innerHeight;\r\n    }\r\n\r\n    start(): void {\r\n        if (this.running) return;\r\n        this.running = true;\r\n        this.render();\r\n    }\r\n\r\n    stop(): void {\r\n        this.running = false;\r\n        if (this.rafId) cancelAnimationFrame(this.rafId);\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n\r\n    private render(): void {\r\n        if (!this.running) return;\r\n\r\n        const w = this.canvas.width;\r\n        const h = this.canvas.height;\r\n        this.ctx.clearRect(0, 0, w, h);\r\n\r\n        const groups = this.getClipGroups();\r\n\r\n        // Apply workspace zoom (same transform as MLMap canvas)\r\n        if (this.zoom !== 1) {\r\n            this.ctx.save();\r\n            const cx = w / 2;\r\n            const cy = h / 2;\r\n            this.ctx.translate(cx, cy);\r\n            this.ctx.scale(this.zoom, this.zoom);\r\n            this.ctx.translate(-cx, -cy);\r\n        }\r\n\r\n        for (const group of groups) {\r\n            const video = group.video;\r\n            if (video.readyState < 2) continue;\r\n\r\n            // Compute bounding box of the base layer's target points\r\n            const basePts = group.baseTargetPoints;\r\n            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\r\n            for (const p of basePts) {\r\n                if (p[0] < minX) minX = p[0];\r\n                if (p[1] < minY) minY = p[1];\r\n                if (p[0] > maxX) maxX = p[0];\r\n                if (p[1] > maxY) maxY = p[1];\r\n            }\r\n            const bw = maxX - minX;\r\n            const bh = maxY - minY;\r\n            if (bw <= 0 || bh <= 0) continue;\r\n\r\n            for (const mask of group.masks) {\r\n                const pts = mask.targetPoints;\r\n                if (!pts || pts.length < 3) continue;\r\n\r\n                this.ctx.save();\r\n                this.ctx.beginPath();\r\n                this.ctx.moveTo(pts[0][0], pts[0][1]);\r\n                for (let i = 1; i < pts.length; i++) {\r\n                    this.ctx.lineTo(pts[i][0], pts[i][1]);\r\n                }\r\n                this.ctx.closePath();\r\n                this.ctx.clip();\r\n\r\n                // Draw the video mapped to the base layer's bounding box\r\n                this.ctx.drawImage(video, minX, minY, bw, bh);\r\n                this.ctx.restore();\r\n            }\r\n        }\r\n\r\n        if (this.zoom !== 1) {\r\n            this.ctx.restore();\r\n        }\r\n\r\n        this.rafId = requestAnimationFrame(() => this.render());\r\n    }\r\n}\r\n", "import { ChannelBridge } from \"../channel\";\r\nimport { VideoState, ManagedLayer } from \"../types\";\r\nimport { applyTransform } from \"../utils/transform\";\r\nimport { SYNC_INTERVAL } from \"../channel/protocol\";\r\nimport { ClipMaskRenderer, ClipGroup } from \"../video/clipMaskRenderer\";\r\n\r\nexport class DisplayRenderer {\r\n    private bridge: ChannelBridge;\r\n    private layers: Map<string, HTMLElement> = new Map();\r\n    private layerInfos: Map<string, ManagedLayer> = new Map();\r\n    private videoElements: Map<string, HTMLVideoElement> = new Map();\r\n    private activeVideo: HTMLVideoElement | null = null;\r\n    private playlist: { url: string; name: string }[] = [];\r\n    private playlistIndex: number = 0;\r\n    private playlistLoop: boolean = true;\r\n    private currentName: string | null = null;\r\n    private syncTimer: number;\r\n    private clipMaskRenderer: ClipMaskRenderer;\r\n    private layoutData: any[] = [];\r\n    private streamPCs: Map<string, RTCPeerConnection> = new Map();\r\n\r\n    constructor() {\r\n        this.bridge = new ChannelBridge(\"display\");\r\n\r\n        this.clipMaskRenderer = new ClipMaskRenderer(() => this.getClipGroups());\r\n        document.body.appendChild(this.clipMaskRenderer.canvasElement);\r\n\r\n        this.bindCommands();\r\n        this.syncTimer = window.setInterval(() => {\r\n            this.bridge.send(\"SYNC_RESPONSE\", this.getState());\r\n        }, SYNC_INTERVAL);\r\n\r\n        // Send display size to editor on resize and fullscreen changes\r\n        const sendResize = () => {\r\n            this.bridge.send(\"DISPLAY_RESIZE\", { width: window.innerWidth, height: window.innerHeight });\r\n        };\r\n        window.addEventListener(\"resize\", sendResize);\r\n        document.addEventListener(\"fullscreenchange\", sendResize);\r\n    }\r\n\r\n    private getClipGroups(): ClipGroup[] {\r\n        const groups: ClipGroup[] = [];\r\n        const grouped = new Map<string, { video: HTMLVideoElement; baseTargetPoints: number[][]; masks: Array<{ targetPoints: number[][] }> }>();\r\n\r\n        for (const [id, info] of this.layerInfos) {\r\n            if (!info.clipTo) continue;\r\n            const baseVideo = this.videoElements.get(info.clipTo);\r\n            if (!baseVideo) continue;\r\n\r\n            const baseLayout = this.layoutData.find((l: any) => l.id === info.clipTo);\r\n            const maskLayout = this.layoutData.find((l: any) => l.id === id);\r\n            if (!baseLayout?.targetPoints || !maskLayout?.targetPoints) continue;\r\n\r\n            if (!grouped.has(info.clipTo)) {\r\n                grouped.set(info.clipTo, {\r\n                    video: baseVideo,\r\n                    baseTargetPoints: baseLayout.targetPoints,\r\n                    masks: []\r\n                });\r\n            }\r\n            grouped.get(info.clipTo)!.masks.push({\r\n                targetPoints: maskLayout.targetPoints\r\n            });\r\n        }\r\n\r\n        for (const g of grouped.values()) groups.push(g);\r\n        return groups;\r\n    }\r\n\r\n    private updateClipMaskState(): void {\r\n        const hiddenBases = new Set<string>();\r\n        for (const [id, info] of this.layerInfos) {\r\n            if (!info.clipTo) continue;\r\n            const el = this.layers.get(id);\r\n            if (el) el.style.opacity = \"0\";\r\n            hiddenBases.add(info.clipTo);\r\n        }\r\n        for (const baseId of hiddenBases) {\r\n            const el = this.layers.get(baseId);\r\n            if (el) el.style.opacity = \"0\";\r\n            // Auto-play base video so the ClipMaskRenderer canvas has frames to draw\r\n            const video = this.videoElements.get(baseId);\r\n            if (video && video.paused && video.src && video.src !== window.location.href) {\r\n                video.play().catch(() => {});\r\n            }\r\n        }\r\n        if (hiddenBases.size > 0) this.clipMaskRenderer.start();\r\n        else this.clipMaskRenderer.stop();\r\n    }\r\n\r\n    private getState(): VideoState {\r\n        const v = this.activeVideo;\r\n        return {\r\n            playing: v ? !v.paused : false,\r\n            currentTime: v?.currentTime || 0,\r\n            duration: v?.duration || 0,\r\n            volume: v?.volume || 1,\r\n            muted: v?.muted ?? true,\r\n            currentName: this.currentName,\r\n            playlistIndex: this.playlistIndex,\r\n            isFullscreen: !!document.fullscreenElement,\r\n        };\r\n    }\r\n\r\n    private bindCommands(): void {\r\n        this.bridge.on(\"ADD_LAYER\", (p: ManagedLayer) => {\r\n            if (this.layers.has(p.id)) {\r\n                // Layer already exists \u2014 update info (e.g. clipTo changed)\r\n                this.layerInfos.set(p.id, p);\r\n                this.updateClipMaskState();\r\n                return;\r\n            }\r\n            this.layerInfos.set(p.id, p);\r\n            const el = this.createLayerElement(p);\r\n            document.body.appendChild(el);\r\n            this.layers.set(p.id, el);\r\n            this.updateClipMaskState();\r\n        });\r\n\r\n        this.bridge.on(\"REMOVE_LAYER\", (p: { id: string }) => {\r\n            const pc = this.streamPCs.get(p.id);\r\n            if (pc) { pc.close(); this.streamPCs.delete(p.id); }\r\n            const el = this.layers.get(p.id);\r\n            if (el) {\r\n                el.remove();\r\n                this.layers.delete(p.id);\r\n                this.layerInfos.delete(p.id);\r\n                this.videoElements.delete(p.id);\r\n            }\r\n            this.updateClipMaskState();\r\n        });\r\n\r\n        this.bridge.on(\"UPDATE_LAYOUT\", (p: { layout: any[] }) => {\r\n            if (!p.layout) return;\r\n            this.layoutData = p.layout;\r\n            for (const item of p.layout) {\r\n                const el = this.layers.get(item.id);\r\n                const info = this.layerInfos.get(item.id);\r\n                // Don't apply CSS transform to clip mask shapes (canvas renders them)\r\n                if (info && info.clipTo) continue;\r\n                if (el && item.sourcePoints && item.targetPoints) {\r\n                    applyTransform(el, item.sourcePoints, item.targetPoints);\r\n                }\r\n            }\r\n            this.updateClipMaskState();\r\n        });\r\n\r\n        this.bridge.on(\"LOAD_PLAYLIST\", (p) => {\r\n            this.playlist = p.items || [];\r\n            this.playlistLoop = p.loop ?? true;\r\n            this.playlistIndex = p.startIndex || 0;\r\n            // Don't auto-load: video layers keep their own source\r\n            // Playlist items load on PLAY (when no source), NEXT, or PREVIOUS\r\n        });\r\n\r\n        this.bridge.on(\"LOAD_VIDEO\", (p) => {\r\n            if (p.url && this.activeVideo) {\r\n                this.currentName = p.name || null;\r\n                this.activeVideo.src = p.url;\r\n                this.activeVideo.load();\r\n            }\r\n        });\r\n\r\n        this.bridge.on(\"PLAY\", () => {\r\n            if (this.activeVideo) {\r\n                // If no source loaded yet, try loading from playlist\r\n                if ((!this.activeVideo.src || this.activeVideo.src === window.location.href) && this.playlist.length > 0) {\r\n                    this.loadCurrentItem();\r\n                }\r\n                this.activeVideo.play().catch(() => {});\r\n            }\r\n        });\r\n\r\n        this.bridge.on(\"PAUSE\", () => {\r\n            if (this.activeVideo) this.activeVideo.pause();\r\n        });\r\n\r\n        this.bridge.on(\"STOP\", () => {\r\n            if (this.activeVideo) {\r\n                this.activeVideo.pause();\r\n                this.activeVideo.currentTime = 0;\r\n            }\r\n        });\r\n\r\n        this.bridge.on(\"SEEK\", (p) => {\r\n            if (typeof p.time === \"number\") {\r\n                if (this.activeVideo) this.activeVideo.currentTime = p.time;\r\n            }\r\n        });\r\n\r\n        this.bridge.on(\"NEXT\", () => this.next());\r\n        this.bridge.on(\"PREVIOUS\", () => this.previous());\r\n\r\n        this.bridge.on(\"SET_VOLUME\", (p) => {\r\n            const vol = Math.max(0, Math.min(1, p.volume));\r\n            if (this.activeVideo) this.activeVideo.volume = vol;\r\n        });\r\n\r\n        this.bridge.on(\"SET_MUTED\", (p) => {\r\n            if (typeof p.muted === \"boolean\") {\r\n                if (this.activeVideo) this.activeVideo.muted = p.muted;\r\n            }\r\n        });\r\n\r\n        this.bridge.on(\"FULLSCREEN_ENTER\", () => {\r\n            document.documentElement.requestFullscreen().catch(() => {});\r\n        });\r\n\r\n        this.bridge.on(\"FULLSCREEN_EXIT\", () => {\r\n            if (document.fullscreenElement) document.exitFullscreen().catch(() => {});\r\n        });\r\n\r\n        this.bridge.on(\"SEND_VIDEO_DATA\", (p: { layerId: string; data: ArrayBuffer; mimeType: string }) => {\r\n            const video = this.videoElements.get(p.layerId);\r\n            if (!video) return;\r\n            const blob = new Blob([p.data], { type: p.mimeType || \"video/mp4\" });\r\n            const url = URL.createObjectURL(blob);\r\n            video.src = url;\r\n            video.load();\r\n            this.updateClipMaskState();\r\n        });\r\n\r\n        // Live stream (screen capture / webcam) via WebRTC (non-trickle ICE)\r\n        this.bridge.on(\"RTC_OFFER\", async (p: { layerId: string; sdp: RTCSessionDescriptionInit }) => {\r\n            const oldPc = this.streamPCs.get(p.layerId);\r\n            if (oldPc) oldPc.close();\r\n            const pc = new RTCPeerConnection();\r\n            this.streamPCs.set(p.layerId, pc);\r\n            pc.ontrack = (e) => {\r\n                const video = this.videoElements.get(p.layerId);\r\n                if (video) {\r\n                    video.srcObject = e.streams[0] || new MediaStream([e.track]);\r\n                    video.autoplay = true;\r\n                    video.play().catch(() => {});\r\n                }\r\n                this.updateClipMaskState();\r\n            };\r\n            await pc.setRemoteDescription(p.sdp);\r\n            const answer = await pc.createAnswer();\r\n            await pc.setLocalDescription(answer);\r\n            // Wait for ICE gathering (fast for local connections)\r\n            if (pc.iceGatheringState !== \"complete\") {\r\n                await new Promise<void>(r => {\r\n                    pc.addEventListener(\"icegatheringstatechange\", () => {\r\n                        if (pc.iceGatheringState === \"complete\") r();\r\n                    });\r\n                });\r\n            }\r\n            this.bridge.send(\"RTC_ANSWER\", { layerId: p.layerId, sdp: pc.localDescription!.toJSON() });\r\n        });\r\n\r\n        this.bridge.on(\"INIT_STATE\", (p) => {\r\n            if (p.layers) {\r\n                for (const layer of p.layers) {\r\n                    if (!this.layers.has(layer.id)) {\r\n                        this.layerInfos.set(layer.id, layer);\r\n                        const el = this.createLayerElement(layer);\r\n                        document.body.appendChild(el);\r\n                        this.layers.set(layer.id, el);\r\n                    }\r\n                }\r\n            }\r\n            if (p.layout) {\r\n                this.layoutData = p.layout;\r\n                for (const item of p.layout) {\r\n                    const el = this.layers.get(item.id);\r\n                    const info = this.layerInfos.get(item.id);\r\n                    if (info && info.clipTo) continue;\r\n                    if (el && item.sourcePoints && item.targetPoints) {\r\n                        applyTransform(el, item.sourcePoints, item.targetPoints);\r\n                    }\r\n                }\r\n            }\r\n            if (p.playlist) {\r\n                this.playlist = p.playlist.items || [];\r\n                this.playlistLoop = p.playlist.loop ?? true;\r\n                this.playlistIndex = p.playlist.startIndex || 0;\r\n            }\r\n            this.updateClipMaskState();\r\n        });\r\n    }\r\n\r\n    private createLayerElement(info: ManagedLayer): HTMLElement {\r\n        const div = document.createElement(\"div\");\r\n        div.id = info.id;\r\n        div.style.position = \"fixed\";\r\n        div.style.top = \"0px\";\r\n        div.style.left = \"0px\";\r\n        div.style.width = info.width + \"px\";\r\n        div.style.height = info.height + \"px\";\r\n        div.style.overflow = \"hidden\";\r\n\r\n        if (info.type === \"video\") {\r\n            div.style.background = \"#000\";\r\n            const video = document.createElement(\"video\");\r\n            if (info.videoUrl) video.src = info.videoUrl;\r\n            video.style.width = \"100%\";\r\n            video.style.height = \"100%\";\r\n            video.style.objectFit = \"contain\";\r\n            video.muted = true;\r\n            video.playsInline = true;\r\n            video.addEventListener(\"ended\", () => this.onVideoEnded());\r\n            div.appendChild(video);\r\n            this.videoElements.set(info.id, video);\r\n            this.activeVideo = video;\r\n        } else if (info.type === \"iframe\" && info.iframeUrl) {\r\n            div.style.background = \"#000\";\r\n            const iframe = document.createElement(\"iframe\");\r\n            iframe.src = info.iframeUrl;\r\n            iframe.style.width = \"100%\";\r\n            iframe.style.height = \"100%\";\r\n            iframe.style.border = \"none\";\r\n            iframe.style.pointerEvents = \"none\";\r\n            iframe.setAttribute(\"allow\", \"autoplay; encrypted-media\");\r\n            div.appendChild(iframe);\r\n        } else if (info.type === \"shape\") {\r\n            if (info.shapeType === \"circle\") {\r\n                div.style.background = \"white\";\r\n                div.style.borderRadius = \"50%\";\r\n            } else if (info.shapeType === \"triangle\") {\r\n                div.style.width = \"0\";\r\n                div.style.height = \"0\";\r\n                div.style.borderLeft = (info.width / 2) + \"px solid transparent\";\r\n                div.style.borderRight = (info.width / 2) + \"px solid transparent\";\r\n                div.style.borderBottom = info.height + \"px solid white\";\r\n                div.style.background = \"transparent\";\r\n            } else {\r\n                div.style.background = \"white\";\r\n            }\r\n        }\r\n\r\n        return div;\r\n    }\r\n\r\n    private loadCurrentItem(): void {\r\n        if (!this.activeVideo || this.playlist.length === 0) return;\r\n        const item = this.playlist[this.playlistIndex];\r\n        if (!item) return;\r\n        this.currentName = item.name;\r\n        this.activeVideo.src = item.url;\r\n        this.activeVideo.load();\r\n    }\r\n\r\n    private next(): void {\r\n        if (this.playlist.length === 0) return;\r\n        this.playlistIndex++;\r\n        if (this.playlistIndex >= this.playlist.length) {\r\n            this.playlistIndex = this.playlistLoop ? 0 : this.playlist.length - 1;\r\n            if (!this.playlistLoop) return;\r\n        }\r\n        this.loadCurrentItem();\r\n        if (this.activeVideo) this.activeVideo.play().catch(() => {});\r\n    }\r\n\r\n    private previous(): void {\r\n        if (this.playlist.length === 0) return;\r\n        this.playlistIndex--;\r\n        if (this.playlistIndex < 0) {\r\n            this.playlistIndex = this.playlistLoop ? this.playlist.length - 1 : 0;\r\n            if (!this.playlistLoop) return;\r\n        }\r\n        this.loadCurrentItem();\r\n        if (this.activeVideo) this.activeVideo.play().catch(() => {});\r\n    }\r\n\r\n    private onVideoEnded(): void {\r\n        if (this.playlist.length > 0) this.next();\r\n    }\r\n}\r\n", "import { DisplayRenderer } from \"./renderer\";\r\n\r\nfunction init(): void {\r\n    const overlay = document.getElementById(\"activate-overlay\");\r\n\r\n    if (overlay) {\r\n        overlay.addEventListener(\"click\", () => {\r\n            overlay.classList.add(\"hidden\");\r\n            document.documentElement.requestFullscreen().catch(() => {\r\n                console.log(\"MLMap Display: Fullscreen not available, continuing without it.\");\r\n            });\r\n        });\r\n        // Re-show overlay when fullscreen is lost (e.g., file dialog or Alt+Tab)\r\n        document.addEventListener(\"fullscreenchange\", () => {\r\n            if (!document.fullscreenElement && overlay.classList.contains(\"hidden\")) {\r\n                (overlay.querySelector(\"span\") as HTMLElement).textContent = \"Click to re-enter fullscreen\";\r\n                overlay.classList.remove(\"hidden\");\r\n            }\r\n        });\r\n    }\r\n\r\n    try {\r\n        new DisplayRenderer();\r\n        console.log(\"MLMap Display: Renderer initialized.\");\r\n    } catch (e) {\r\n        console.error(\"MLMap Display: Failed to initialize renderer.\", e);\r\n    }\r\n}\r\n\r\nif (document.readyState === \"loading\") {\r\n    document.addEventListener(\"DOMContentLoaded\", init);\r\n} else {\r\n    init();\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
